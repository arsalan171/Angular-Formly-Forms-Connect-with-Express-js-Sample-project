import { Component, ViewChild, ViewContainerRef, Pipe, NgModule } from '@angular/core';
import { FieldType, FieldWrapper, FormlyModule } from '@ngx-formly/core';
import { FormGroup, FormControl, ReactiveFormsModule } from '@angular/forms';
import { Observable, of } from 'rxjs';
import { map } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FormlyFieldCheckbox extends FieldType {
}
FormlyFieldCheckbox.decorators = [
    { type: Component, args: [{
                selector: 'formly-field-checkbox',
                template: `
    <label class="custom-control custom-checkbox">
      <input type="checkbox" [formControl]="formControl"
        [attr.invalid]="showError"
        [indeterminate]="to.indeterminate && model[key] === undefined"
        [formlyAttributes]="field" class="custom-control-input">
        <span class="custom-control-label">
          {{ to.label }}
          <ng-container *ngIf="to.required && to.hideRequiredMarker !== true">*</ng-container>
        </span>
        <span class="custom-control-indicator"></span>
    </label>
  `,
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FormlyFieldMultiCheckbox extends FieldType {
    /**
     * @param {?} model
     * @param {?} field
     * @return {?}
     */
    static createControl(model, field) {
        if (!(field.templateOptions.options instanceof Observable)) {
            let /** @type {?} */ controlGroupConfig = field.templateOptions.options.reduce((previous, option) => {
                previous[option.key] = new FormControl(model ? model[option.key] : undefined);
                return previous;
            }, {});
            return new FormGroup(controlGroupConfig, field.validators ? field.validators.validation : undefined, field.asyncValidators ? field.asyncValidators.validation : undefined);
        }
        else {
            throw new Error(`[Formly Error] You cannot pass an Observable to a multicheckbox yet.`);
        }
    }
}
FormlyFieldMultiCheckbox.decorators = [
    { type: Component, args: [{
                selector: 'formly-field-multicheckbox',
                template: `
    <div *ngFor="let option of to.options; let i = index;" class="checkbox">
      <label class="custom-control custom-checkbox">
        <input type="checkbox"
          [value]="option.value"
          [id]="id + '_' + i"
          [formControl]="formControl.get(option.key)"
          [formlyAttributes]="field" class="custom-control-input">
        <span class="custom-control-label">{{ option.value }}</span>
        <span class="custom-control-indicator"></span>
      </label>
    </div>
  `,
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FormlyFieldInput extends FieldType {
    /**
     * @return {?}
     */
    get type() {
        return this.to.type || 'text';
    }
}
FormlyFieldInput.decorators = [
    { type: Component, args: [{
                selector: 'formly-field-input',
                template: `
    <input *ngIf="type !== 'number' else numberTmp" [type]="type" [formControl]="formControl" class="form-control" [formlyAttributes]="field" [class.is-invalid]="showError">
    <ng-template #numberTmp>
      <input type="number" [formControl]="formControl" class="form-control" [formlyAttributes]="field" [class.is-invalid]="showError">
    </ng-template>
  `,
                host: {
                    // temporary fix until removing bootstrap 3 support.
                    '[class.d-inline-flex]': 'to.addonLeft || to.addonRight',
                    '[class.custom-file]': 'to.addonLeft || to.addonRight',
                },
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FormlyFieldRadio extends FieldType {
}
FormlyFieldRadio.decorators = [
    { type: Component, args: [{
                selector: 'formly-field-radio',
                template: `
    <div [formGroup]="form">
      <div *ngFor="let option of to.options; let i = index;" class="radio">
        <label class="custom-control custom-radio">
          <input
            [name]="id"
            [id]="id + '_' + i"
            type="radio"
            [value]="option.label ? option.value : option.key"
            [formControl]="formControl"
            [formlyAttributes]="field" class="custom-control-input">

          <span class="custom-control-label">{{ option.label ? option.label : option.value }}</span>
          <span class="custom-control-indicator"></span>
        </label>
      </div>
    </div>
  `,
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FormlyFieldTextArea extends FieldType {
}
FormlyFieldTextArea.decorators = [
    { type: Component, args: [{
                selector: 'formly-field-textarea',
                template: `
    <textarea [name]="key" [formControl]="formControl" [cols]="to.cols"
      [rows]="to.rows" class="form-control" [class.is-invalid]="showError"
      [formlyAttributes]="field">
    </textarea>
  `,
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FormlyFieldSelect extends FieldType {
}
FormlyFieldSelect.decorators = [
    { type: Component, args: [{
                selector: 'formly-field-select',
                template: `
    <select *ngIf="to.multiple; else singleSelect" class="form-control"
      [formControl]="formControl"
      [class.is-invalid]="showError"
      [multiple]="true"
      [formlyAttributes]="field">
        <ng-container *ngFor="let item of to.options | formlySelectOptions:field | async">
         <optgroup *ngIf="item.group" label="{{item.label}}">
            <option *ngFor="let child of item.group" [value]="child.value" [disabled]="child.disabled">
              {{ child.label }}
            </option>
          </optgroup>
          <option *ngIf="!item.group" [value]="item.value" [disabled]="item.disabled">{{ item.label }}</option>
        </ng-container>
    </select>

    <ng-template #singleSelect>
      <select class="form-control"
        [formControl]="formControl"
        [class.is-invalid]="showError"
        [formlyAttributes]="field">
        <option *ngIf="to.placeholder" value="">{{ to.placeholder }}</option>
        <ng-container *ngFor="let item of to.options | formlySelectOptions:field | async">
          <optgroup *ngIf="item.group" label="{{item.label}}">
            <option *ngFor="let child of item.group" [value]="child.value" [disabled]="child.disabled">
              {{ child.label }}
            </option>
          </optgroup>
          <option *ngIf="!item.group" [value]="item.value" [disabled]="item.disabled">{{ item.label }}</option>
        </ng-container>
      </select>
    </ng-template>
  `,
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FormlyWrapperFieldset extends FieldWrapper {
}
FormlyWrapperFieldset.decorators = [
    { type: Component, args: [{
                selector: 'formly-wrapper-fieldset',
                template: `
    <div class="form-group" [class.has-error]="showError">
      <ng-template #fieldComponent></ng-template>
    </div>
  `,
            },] },
];
FormlyWrapperFieldset.propDecorators = {
    fieldComponent: [{ type: ViewChild, args: ['fieldComponent', { read: ViewContainerRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FormlyWrapperLabel extends FieldWrapper {
}
FormlyWrapperLabel.decorators = [
    { type: Component, args: [{
                selector: 'formly-wrapper-label',
                template: `
    <label [attr.for]="id" class="form-control-label control-label" *ngIf="to.label">
      {{ to.label }}
      <ng-container *ngIf="to.required && to.hideRequiredMarker !== true">*</ng-container>
    </label>
    <ng-template #fieldComponent></ng-template>
  `,
            },] },
];
FormlyWrapperLabel.propDecorators = {
    fieldComponent: [{ type: ViewChild, args: ['fieldComponent', { read: ViewContainerRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FormlyWrapperDescription extends FieldWrapper {
}
FormlyWrapperDescription.decorators = [
    { type: Component, args: [{
                selector: 'formly-wrapper-description',
                template: `
    <ng-template #fieldComponent></ng-template>
    <div *ngIf="to.description">
      <small class="text-muted">{{ to.description }}</small>
    </div>
  `,
            },] },
];
FormlyWrapperDescription.propDecorators = {
    fieldComponent: [{ type: ViewChild, args: ['fieldComponent', { read: ViewContainerRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FormlyWrapperValidationMessages extends FieldWrapper {
    /**
     * @return {?}
     */
    get validationId() {
        return this.field.id + '-message';
    }
}
FormlyWrapperValidationMessages.decorators = [
    { type: Component, args: [{
                selector: 'formly-wrapper-validation-messages',
                template: `
    <ng-template #fieldComponent></ng-template>
    <div *ngIf="showError">
      <small class="text-danger invalid-feedback" [style.display]="'block'" role="alert" [id]="validationId">
        <formly-validation-message [field]="field"></formly-validation-message>
      </small>
    </div>
  `,
            },] },
];
FormlyWrapperValidationMessages.propDecorators = {
    fieldComponent: [{ type: ViewChild, args: ['fieldComponent', { read: ViewContainerRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FormlyWrapperAddons extends FieldWrapper {
    /**
     * @param {?} $event
     * @return {?}
     */
    addonRightClick($event) {
        if (this.to["addonRight"].onClick) {
            this.to["addonRight"].onClick(this.to, this, $event);
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    addonLeftClick($event) {
        if (this.to["addonLeft"].onClick) {
            this.to["addonLeft"].onClick(this.to, this, $event);
        }
    }
}
FormlyWrapperAddons.decorators = [
    { type: Component, args: [{
                selector: 'formly-wrapper-addons',
                template: `
    <div class="input-group">
      <div class="input-group-addon input-group-prepend"
        *ngIf="to.addonLeft"
        [ngStyle]="{cursor: to.addonLeft.onClick ? 'pointer' : 'inherit'}"
        (click)="addonLeftClick($event)">
        <i class="input-group-text" [ngClass]="to.addonLeft.class" *ngIf="to.addonLeft.class"></i>
        <span *ngIf="to.addonLeft.text" class="input-group-text">{{ to.addonLeft.text }}</span>
      </div>
      <ng-template #fieldComponent></ng-template>
      <div class="input-group-addon input-group-append"
        *ngIf="to.addonRight"
        [ngStyle]="{cursor: to.addonRight.onClick ? 'pointer' : 'inherit'}"
        (click)="addonRightClick($event)">
        <i class="input-group-text" [ngClass]="to.addonRight.class" *ngIf="to.addonRight.class"></i>
        <span *ngIf="to.addonRight.text" class="input-group-text">{{ to.addonRight.text }}</span>
      </div>
    </div>
  `,
                styles: [`
    :host ::ng-deep .input-group>:not(:first-child)> .form-control {
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }
    :host ::ng-deep .input-group>:not(:last-child)> .form-control {
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
    }
  `],
            },] },
];
FormlyWrapperAddons.propDecorators = {
    fieldComponent: [{ type: ViewChild, args: ['fieldComponent', { read: ViewContainerRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TemplateDescription {
    /**
     * @param {?} fc
     * @return {?}
     */
    run(fc) {
        fc.templateManipulators.postWrapper.push((field) => {
            if (!field.templateOptions || field.templateOptions["descriptionWrapper"] !== false) {
                return 'description';
            }
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TemplateValidation {
    /**
     * @param {?} fc
     * @return {?}
     */
    run(fc) {
        fc.templateManipulators.postWrapper.push((field) => {
            if (!field.templateOptions || field.templateOptions["validationWrapper"] !== false) {
                return 'validation-message';
            }
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TemplateAddons {
    /**
     * @param {?} fc
     * @return {?}
     */
    run(fc) {
        fc.templateManipulators.postWrapper.push((field) => {
            if (field && field.templateOptions && (field.templateOptions["addonLeft"] || field.templateOptions["addonRight"])) {
                return 'addons';
            }
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ FIELD_TYPE_COMPONENTS = [
    FormlyFieldInput,
    FormlyFieldCheckbox,
    FormlyFieldRadio,
    FormlyFieldSelect,
    FormlyFieldTextArea,
    FormlyFieldMultiCheckbox,
    FormlyWrapperLabel,
    FormlyWrapperDescription,
    FormlyWrapperValidationMessages,
    FormlyWrapperFieldset,
    FormlyWrapperAddons,
];
const /** @type {?} */ BOOTSTRAP_FORMLY_CONFIG = {
    types: [
        {
            name: 'input',
            component: FormlyFieldInput,
            wrappers: ['fieldset', 'label'],
        },
        {
            name: 'checkbox',
            component: FormlyFieldCheckbox,
            wrappers: ['fieldset'],
            defaultOptions: {
                templateOptions: {
                    indeterminate: true,
                },
            },
        },
        {
            name: 'radio',
            component: FormlyFieldRadio,
            wrappers: ['fieldset', 'label'],
            defaultOptions: {
                templateOptions: {
                    options: [],
                },
            },
        },
        {
            name: 'select',
            component: FormlyFieldSelect,
            wrappers: ['fieldset', 'label'],
            defaultOptions: {
                templateOptions: {
                    options: [],
                },
            },
        },
        {
            name: 'textarea',
            component: FormlyFieldTextArea,
            wrappers: ['fieldset', 'label'],
            defaultOptions: {
                templateOptions: {
                    cols: 1,
                    rows: 1,
                },
            },
        },
        {
            name: 'multicheckbox',
            component: FormlyFieldMultiCheckbox,
            wrappers: ['fieldset', 'label'],
            defaultOptions: {
                templateOptions: {
                    options: [],
                },
            },
        },
    ],
    wrappers: [
        { name: 'label', component: FormlyWrapperLabel },
        { name: 'description', component: FormlyWrapperDescription },
        { name: 'validation-message', component: FormlyWrapperValidationMessages },
        { name: 'fieldset', component: FormlyWrapperFieldset },
        { name: 'addons', component: FormlyWrapperAddons },
    ],
    manipulators: [
        { class: TemplateDescription, method: 'run' },
        { class: TemplateValidation, method: 'run' },
        { class: TemplateAddons, method: 'run' },
    ],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FormlySelectOptionsPipe {
    /**
     * @param {?} options
     * @param {?=} field
     * @return {?}
     */
    transform(options, field) {
        if (!(options instanceof Observable)) {
            options = of(options);
        }
        return (/** @type {?} */ (options)).pipe(map(value => this.toOptions(value, field || {})));
    }
    /**
     * @param {?} options
     * @param {?} field
     * @return {?}
     */
    toOptions(options, field) {
        const /** @type {?} */ gOptions = [], /** @type {?} */
        groups = {}, /** @type {?} */
        to = field.templateOptions || {};
        options.map((option) => {
            if (!this.getGroupProp(option, to)) {
                gOptions.push(this.toOption(option, to));
            }
            else {
                if (!groups[this.getGroupProp(option, to)]) {
                    groups[this.getGroupProp(option, to)] = [];
                    gOptions.push({
                        label: this.getGroupProp(option, to),
                        group: groups[this.getGroupProp(option, to)],
                    });
                }
                groups[this.getGroupProp(option, to)].push(this.toOption(option, to));
            }
        });
        return gOptions;
    }
    /**
     * @param {?} item
     * @param {?} to
     * @return {?}
     */
    toOption(item, to) {
        return {
            label: this.getLabelProp(item, to),
            value: this.getValueProp(item, to),
        };
    }
    /**
     * @param {?} item
     * @param {?} to
     * @return {?}
     */
    getLabelProp(item, to) {
        if (typeof to.labelProp === 'function') {
            return to.labelProp(item);
        }
        return item[to.labelProp || 'label'];
    }
    /**
     * @param {?} item
     * @param {?} to
     * @return {?}
     */
    getValueProp(item, to) {
        if (typeof to.valueProp === 'function') {
            return to.valueProp(item);
        }
        return item[to.valueProp || 'value'];
    }
    /**
     * @param {?} item
     * @param {?} to
     * @return {?}
     */
    getGroupProp(item, to) {
        if (typeof to.groupProp === 'function') {
            return to.groupProp(item);
        }
        return item[to.groupProp || 'group'];
    }
}
FormlySelectOptionsPipe.decorators = [
    { type: Pipe, args: [{ name: 'formlySelectOptions' },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FormlyBootstrapModule {
}
FormlyBootstrapModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    FIELD_TYPE_COMPONENTS,
                    FormlySelectOptionsPipe,
                ],
                imports: [
                    CommonModule,
                    ReactiveFormsModule,
                    FormlyModule.forRoot(BOOTSTRAP_FORMLY_CONFIG),
                ],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { FormlyBootstrapModule, FormlyFieldCheckbox, FormlyFieldMultiCheckbox, FormlyFieldInput, FormlyFieldRadio, FormlyFieldTextArea, FormlyFieldSelect, FormlyWrapperFieldset, FormlyWrapperLabel, FormlyWrapperDescription, FormlyWrapperValidationMessages, BOOTSTRAP_FORMLY_CONFIG as ɵb, FIELD_TYPE_COMPONENTS as ɵa, TemplateAddons as ɵg, TemplateDescription as ɵe, TemplateValidation as ɵf, FormlySelectOptionsPipe as ɵd, FormlyWrapperAddons as ɵc };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWZvcm1seS1ib290c3RyYXAuanMubWFwIiwic291cmNlcyI6WyJuZzovL0BuZ3gtZm9ybWx5L2Jvb3RzdHJhcC9saWIvdHlwZXMvY2hlY2tib3gudHMiLCJuZzovL0BuZ3gtZm9ybWx5L2Jvb3RzdHJhcC9saWIvdHlwZXMvbXVsdGljaGVja2JveC50cyIsIm5nOi8vQG5neC1mb3JtbHkvYm9vdHN0cmFwL2xpYi90eXBlcy9pbnB1dC50cyIsIm5nOi8vQG5neC1mb3JtbHkvYm9vdHN0cmFwL2xpYi90eXBlcy9yYWRpby50cyIsIm5nOi8vQG5neC1mb3JtbHkvYm9vdHN0cmFwL2xpYi90eXBlcy90ZXh0YXJlYS50cyIsIm5nOi8vQG5neC1mb3JtbHkvYm9vdHN0cmFwL2xpYi90eXBlcy9zZWxlY3QudHMiLCJuZzovL0BuZ3gtZm9ybWx5L2Jvb3RzdHJhcC9saWIvd3JhcHBlcnMvZmllbGRzZXQudHMiLCJuZzovL0BuZ3gtZm9ybWx5L2Jvb3RzdHJhcC9saWIvd3JhcHBlcnMvbGFiZWwudHMiLCJuZzovL0BuZ3gtZm9ybWx5L2Jvb3RzdHJhcC9saWIvd3JhcHBlcnMvZGVzY3JpcHRpb24udHMiLCJuZzovL0BuZ3gtZm9ybWx5L2Jvb3RzdHJhcC9saWIvd3JhcHBlcnMvbWVzc2FnZS12YWxpZGF0aW9uLnRzIiwibmc6Ly9Abmd4LWZvcm1seS9ib290c3RyYXAvbGliL3dyYXBwZXJzL2FkZG9ucy50cyIsIm5nOi8vQG5neC1mb3JtbHkvYm9vdHN0cmFwL2xpYi9ydW4vZGVzY3JpcHRpb24udHMiLCJuZzovL0BuZ3gtZm9ybWx5L2Jvb3RzdHJhcC9saWIvcnVuL3ZhbGlkYXRpb24udHMiLCJuZzovL0BuZ3gtZm9ybWx5L2Jvb3RzdHJhcC9saWIvcnVuL2FkZG9uLnRzIiwibmc6Ly9Abmd4LWZvcm1seS9ib290c3RyYXAvbGliL2Jvb3RzdHJhcC5jb25maWcudHMiLCJuZzovL0BuZ3gtZm9ybWx5L2Jvb3RzdHJhcC9saWIvc2VsZWN0LW9wdGlvbnMucGlwZS50cyIsIm5nOi8vQG5neC1mb3JtbHkvYm9vdHN0cmFwL2xpYi9ib290c3RyYXAubW9kdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRmllbGRUeXBlIH0gZnJvbSAnQG5neC1mb3JtbHkvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Zvcm1seS1maWVsZC1jaGVja2JveCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgPGxhYmVsIGNsYXNzPVwiY3VzdG9tLWNvbnRyb2wgY3VzdG9tLWNoZWNrYm94XCI+XG4gICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgW2Zvcm1Db250cm9sXT1cImZvcm1Db250cm9sXCJcbiAgICAgICAgW2F0dHIuaW52YWxpZF09XCJzaG93RXJyb3JcIlxuICAgICAgICBbaW5kZXRlcm1pbmF0ZV09XCJ0by5pbmRldGVybWluYXRlICYmIG1vZGVsW2tleV0gPT09IHVuZGVmaW5lZFwiXG4gICAgICAgIFtmb3JtbHlBdHRyaWJ1dGVzXT1cImZpZWxkXCIgY2xhc3M9XCJjdXN0b20tY29udHJvbC1pbnB1dFwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImN1c3RvbS1jb250cm9sLWxhYmVsXCI+XG4gICAgICAgICAge3sgdG8ubGFiZWwgfX1cbiAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwidG8ucmVxdWlyZWQgJiYgdG8uaGlkZVJlcXVpcmVkTWFya2VyICE9PSB0cnVlXCI+KjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L3NwYW4+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiY3VzdG9tLWNvbnRyb2wtaW5kaWNhdG9yXCI+PC9zcGFuPlxuICAgIDwvbGFiZWw+XG4gIGAsXG59KVxuZXhwb3J0IGNsYXNzIEZvcm1seUZpZWxkQ2hlY2tib3ggZXh0ZW5kcyBGaWVsZFR5cGUge31cbiIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybUdyb3VwLCBGb3JtQ29udHJvbCwgQWJzdHJhY3RDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgRmllbGRUeXBlLCBGb3JtbHlGaWVsZENvbmZpZyB9IGZyb20gJ0BuZ3gtZm9ybWx5L2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdmb3JtbHktZmllbGQtbXVsdGljaGVja2JveCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgPGRpdiAqbmdGb3I9XCJsZXQgb3B0aW9uIG9mIHRvLm9wdGlvbnM7IGxldCBpID0gaW5kZXg7XCIgY2xhc3M9XCJjaGVja2JveFwiPlxuICAgICAgPGxhYmVsIGNsYXNzPVwiY3VzdG9tLWNvbnRyb2wgY3VzdG9tLWNoZWNrYm94XCI+XG4gICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgIFt2YWx1ZV09XCJvcHRpb24udmFsdWVcIlxuICAgICAgICAgIFtpZF09XCJpZCArICdfJyArIGlcIlxuICAgICAgICAgIFtmb3JtQ29udHJvbF09XCJmb3JtQ29udHJvbC5nZXQob3B0aW9uLmtleSlcIlxuICAgICAgICAgIFtmb3JtbHlBdHRyaWJ1dGVzXT1cImZpZWxkXCIgY2xhc3M9XCJjdXN0b20tY29udHJvbC1pbnB1dFwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImN1c3RvbS1jb250cm9sLWxhYmVsXCI+e3sgb3B0aW9uLnZhbHVlIH19PC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImN1c3RvbS1jb250cm9sLWluZGljYXRvclwiPjwvc3Bhbj5cbiAgICAgIDwvbGFiZWw+XG4gICAgPC9kaXY+XG4gIGAsXG59KVxuZXhwb3J0IGNsYXNzIEZvcm1seUZpZWxkTXVsdGlDaGVja2JveCBleHRlbmRzIEZpZWxkVHlwZSB7XG4gIHN0YXRpYyBjcmVhdGVDb250cm9sKG1vZGVsOiBhbnksIGZpZWxkOiBGb3JtbHlGaWVsZENvbmZpZyk6IEFic3RyYWN0Q29udHJvbCB7XG4gICAgaWYgKCEoZmllbGQudGVtcGxhdGVPcHRpb25zLm9wdGlvbnMgaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSkge1xuICAgICAgbGV0IGNvbnRyb2xHcm91cENvbmZpZyA9IGZpZWxkLnRlbXBsYXRlT3B0aW9ucy5vcHRpb25zLnJlZHVjZSgocHJldmlvdXMsIG9wdGlvbikgPT4ge1xuICAgICAgICBwcmV2aW91c1tvcHRpb24ua2V5XSA9IG5ldyBGb3JtQ29udHJvbChtb2RlbCA/IG1vZGVsW29wdGlvbi5rZXldIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgICAgfSwge30pO1xuXG4gICAgICByZXR1cm4gbmV3IEZvcm1Hcm91cChcbiAgICAgICAgY29udHJvbEdyb3VwQ29uZmlnLFxuICAgICAgICBmaWVsZC52YWxpZGF0b3JzID8gZmllbGQudmFsaWRhdG9ycy52YWxpZGF0aW9uIDogdW5kZWZpbmVkLFxuICAgICAgICBmaWVsZC5hc3luY1ZhbGlkYXRvcnMgPyBmaWVsZC5hc3luY1ZhbGlkYXRvcnMudmFsaWRhdGlvbiA6IHVuZGVmaW5lZCxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgW0Zvcm1seSBFcnJvcl0gWW91IGNhbm5vdCBwYXNzIGFuIE9ic2VydmFibGUgdG8gYSBtdWx0aWNoZWNrYm94IHlldC5gKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRmllbGRUeXBlIH0gZnJvbSAnQG5neC1mb3JtbHkvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Zvcm1seS1maWVsZC1pbnB1dCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgPGlucHV0ICpuZ0lmPVwidHlwZSAhPT0gJ251bWJlcicgZWxzZSBudW1iZXJUbXBcIiBbdHlwZV09XCJ0eXBlXCIgW2Zvcm1Db250cm9sXT1cImZvcm1Db250cm9sXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBbZm9ybWx5QXR0cmlidXRlc109XCJmaWVsZFwiIFtjbGFzcy5pcy1pbnZhbGlkXT1cInNob3dFcnJvclwiPlxuICAgIDxuZy10ZW1wbGF0ZSAjbnVtYmVyVG1wPlxuICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiBbZm9ybUNvbnRyb2xdPVwiZm9ybUNvbnRyb2xcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIFtmb3JtbHlBdHRyaWJ1dGVzXT1cImZpZWxkXCIgW2NsYXNzLmlzLWludmFsaWRdPVwic2hvd0Vycm9yXCI+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgYCxcbiAgaG9zdDoge1xuICAgIC8vIHRlbXBvcmFyeSBmaXggdW50aWwgcmVtb3ZpbmcgYm9vdHN0cmFwIDMgc3VwcG9ydC5cbiAgICAnW2NsYXNzLmQtaW5saW5lLWZsZXhdJzogJ3RvLmFkZG9uTGVmdCB8fCB0by5hZGRvblJpZ2h0JyxcbiAgICAnW2NsYXNzLmN1c3RvbS1maWxlXSc6ICd0by5hZGRvbkxlZnQgfHwgdG8uYWRkb25SaWdodCcsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIEZvcm1seUZpZWxkSW5wdXQgZXh0ZW5kcyBGaWVsZFR5cGUge1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy50by50eXBlIHx8ICd0ZXh0JztcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGaWVsZFR5cGUgfSBmcm9tICdAbmd4LWZvcm1seS9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZm9ybWx5LWZpZWxkLXJhZGlvJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IFtmb3JtR3JvdXBdPVwiZm9ybVwiPlxuICAgICAgPGRpdiAqbmdGb3I9XCJsZXQgb3B0aW9uIG9mIHRvLm9wdGlvbnM7IGxldCBpID0gaW5kZXg7XCIgY2xhc3M9XCJyYWRpb1wiPlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJjdXN0b20tY29udHJvbCBjdXN0b20tcmFkaW9cIj5cbiAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIFtuYW1lXT1cImlkXCJcbiAgICAgICAgICAgIFtpZF09XCJpZCArICdfJyArIGlcIlxuICAgICAgICAgICAgdHlwZT1cInJhZGlvXCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCJvcHRpb24ubGFiZWwgPyBvcHRpb24udmFsdWUgOiBvcHRpb24ua2V5XCJcbiAgICAgICAgICAgIFtmb3JtQ29udHJvbF09XCJmb3JtQ29udHJvbFwiXG4gICAgICAgICAgICBbZm9ybWx5QXR0cmlidXRlc109XCJmaWVsZFwiIGNsYXNzPVwiY3VzdG9tLWNvbnRyb2wtaW5wdXRcIj5cblxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiY3VzdG9tLWNvbnRyb2wtbGFiZWxcIj57eyBvcHRpb24ubGFiZWwgPyBvcHRpb24ubGFiZWwgOiBvcHRpb24udmFsdWUgfX08L3NwYW4+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJjdXN0b20tY29udHJvbC1pbmRpY2F0b3JcIj48L3NwYW4+XG4gICAgICAgIDwvbGFiZWw+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYCxcbn0pXG5leHBvcnQgY2xhc3MgRm9ybWx5RmllbGRSYWRpbyBleHRlbmRzIEZpZWxkVHlwZSB7fVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGaWVsZFR5cGUgfSBmcm9tICdAbmd4LWZvcm1seS9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZm9ybWx5LWZpZWxkLXRleHRhcmVhJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8dGV4dGFyZWEgW25hbWVdPVwia2V5XCIgW2Zvcm1Db250cm9sXT1cImZvcm1Db250cm9sXCIgW2NvbHNdPVwidG8uY29sc1wiXG4gICAgICBbcm93c109XCJ0by5yb3dzXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBbY2xhc3MuaXMtaW52YWxpZF09XCJzaG93RXJyb3JcIlxuICAgICAgW2Zvcm1seUF0dHJpYnV0ZXNdPVwiZmllbGRcIj5cbiAgICA8L3RleHRhcmVhPlxuICBgLFxufSlcbmV4cG9ydCBjbGFzcyBGb3JtbHlGaWVsZFRleHRBcmVhIGV4dGVuZHMgRmllbGRUeXBlIHtcbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRmllbGRUeXBlIH0gZnJvbSAnQG5neC1mb3JtbHkvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Zvcm1seS1maWVsZC1zZWxlY3QnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxzZWxlY3QgKm5nSWY9XCJ0by5tdWx0aXBsZTsgZWxzZSBzaW5nbGVTZWxlY3RcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiXG4gICAgICBbZm9ybUNvbnRyb2xdPVwiZm9ybUNvbnRyb2xcIlxuICAgICAgW2NsYXNzLmlzLWludmFsaWRdPVwic2hvd0Vycm9yXCJcbiAgICAgIFttdWx0aXBsZV09XCJ0cnVlXCJcbiAgICAgIFtmb3JtbHlBdHRyaWJ1dGVzXT1cImZpZWxkXCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGl0ZW0gb2YgdG8ub3B0aW9ucyB8IGZvcm1seVNlbGVjdE9wdGlvbnM6ZmllbGQgfCBhc3luY1wiPlxuICAgICAgICAgPG9wdGdyb3VwICpuZ0lmPVwiaXRlbS5ncm91cFwiIGxhYmVsPVwie3tpdGVtLmxhYmVsfX1cIj5cbiAgICAgICAgICAgIDxvcHRpb24gKm5nRm9yPVwibGV0IGNoaWxkIG9mIGl0ZW0uZ3JvdXBcIiBbdmFsdWVdPVwiY2hpbGQudmFsdWVcIiBbZGlzYWJsZWRdPVwiY2hpbGQuZGlzYWJsZWRcIj5cbiAgICAgICAgICAgICAge3sgY2hpbGQubGFiZWwgfX1cbiAgICAgICAgICAgIDwvb3B0aW9uPlxuICAgICAgICAgIDwvb3B0Z3JvdXA+XG4gICAgICAgICAgPG9wdGlvbiAqbmdJZj1cIiFpdGVtLmdyb3VwXCIgW3ZhbHVlXT1cIml0ZW0udmFsdWVcIiBbZGlzYWJsZWRdPVwiaXRlbS5kaXNhYmxlZFwiPnt7IGl0ZW0ubGFiZWwgfX08L29wdGlvbj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9zZWxlY3Q+XG5cbiAgICA8bmctdGVtcGxhdGUgI3NpbmdsZVNlbGVjdD5cbiAgICAgIDxzZWxlY3QgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIlxuICAgICAgICBbZm9ybUNvbnRyb2xdPVwiZm9ybUNvbnRyb2xcIlxuICAgICAgICBbY2xhc3MuaXMtaW52YWxpZF09XCJzaG93RXJyb3JcIlxuICAgICAgICBbZm9ybWx5QXR0cmlidXRlc109XCJmaWVsZFwiPlxuICAgICAgICA8b3B0aW9uICpuZ0lmPVwidG8ucGxhY2Vob2xkZXJcIiB2YWx1ZT1cIlwiPnt7IHRvLnBsYWNlaG9sZGVyIH19PC9vcHRpb24+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGl0ZW0gb2YgdG8ub3B0aW9ucyB8IGZvcm1seVNlbGVjdE9wdGlvbnM6ZmllbGQgfCBhc3luY1wiPlxuICAgICAgICAgIDxvcHRncm91cCAqbmdJZj1cIml0ZW0uZ3JvdXBcIiBsYWJlbD1cInt7aXRlbS5sYWJlbH19XCI+XG4gICAgICAgICAgICA8b3B0aW9uICpuZ0Zvcj1cImxldCBjaGlsZCBvZiBpdGVtLmdyb3VwXCIgW3ZhbHVlXT1cImNoaWxkLnZhbHVlXCIgW2Rpc2FibGVkXT1cImNoaWxkLmRpc2FibGVkXCI+XG4gICAgICAgICAgICAgIHt7IGNoaWxkLmxhYmVsIH19XG4gICAgICAgICAgICA8L29wdGlvbj5cbiAgICAgICAgICA8L29wdGdyb3VwPlxuICAgICAgICAgIDxvcHRpb24gKm5nSWY9XCIhaXRlbS5ncm91cFwiIFt2YWx1ZV09XCJpdGVtLnZhbHVlXCIgW2Rpc2FibGVkXT1cIml0ZW0uZGlzYWJsZWRcIj57eyBpdGVtLmxhYmVsIH19PC9vcHRpb24+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgPC9zZWxlY3Q+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgYCxcbn0pXG5leHBvcnQgY2xhc3MgRm9ybWx5RmllbGRTZWxlY3QgZXh0ZW5kcyBGaWVsZFR5cGUge31cbiIsImltcG9ydCB7IENvbXBvbmVudCwgVmlld0NoaWxkLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGaWVsZFdyYXBwZXIgfSBmcm9tICdAbmd4LWZvcm1seS9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZm9ybWx5LXdyYXBwZXItZmllbGRzZXQnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCIgW2NsYXNzLmhhcy1lcnJvcl09XCJzaG93RXJyb3JcIj5cbiAgICAgIDxuZy10ZW1wbGF0ZSAjZmllbGRDb21wb25lbnQ+PC9uZy10ZW1wbGF0ZT5cbiAgICA8L2Rpdj5cbiAgYCxcbn0pXG5leHBvcnQgY2xhc3MgRm9ybWx5V3JhcHBlckZpZWxkc2V0IGV4dGVuZHMgRmllbGRXcmFwcGVyIHtcbiAgQFZpZXdDaGlsZCgnZmllbGRDb21wb25lbnQnLCB7cmVhZDogVmlld0NvbnRhaW5lclJlZn0pIGZpZWxkQ29tcG9uZW50OiBWaWV3Q29udGFpbmVyUmVmO1xufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBWaWV3Q2hpbGQsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZpZWxkV3JhcHBlciB9IGZyb20gJ0BuZ3gtZm9ybWx5L2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdmb3JtbHktd3JhcHBlci1sYWJlbCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgPGxhYmVsIFthdHRyLmZvcl09XCJpZFwiIGNsYXNzPVwiZm9ybS1jb250cm9sLWxhYmVsIGNvbnRyb2wtbGFiZWxcIiAqbmdJZj1cInRvLmxhYmVsXCI+XG4gICAgICB7eyB0by5sYWJlbCB9fVxuICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInRvLnJlcXVpcmVkICYmIHRvLmhpZGVSZXF1aXJlZE1hcmtlciAhPT0gdHJ1ZVwiPio8L25nLWNvbnRhaW5lcj5cbiAgICA8L2xhYmVsPlxuICAgIDxuZy10ZW1wbGF0ZSAjZmllbGRDb21wb25lbnQ+PC9uZy10ZW1wbGF0ZT5cbiAgYCxcbn0pXG5leHBvcnQgY2xhc3MgRm9ybWx5V3JhcHBlckxhYmVsIGV4dGVuZHMgRmllbGRXcmFwcGVyIHtcbiAgQFZpZXdDaGlsZCgnZmllbGRDb21wb25lbnQnLCB7cmVhZDogVmlld0NvbnRhaW5lclJlZn0pIGZpZWxkQ29tcG9uZW50OiBWaWV3Q29udGFpbmVyUmVmO1xufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBWaWV3Q2hpbGQsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZpZWxkV3JhcHBlciB9IGZyb20gJ0BuZ3gtZm9ybWx5L2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdmb3JtbHktd3JhcHBlci1kZXNjcmlwdGlvbicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLXRlbXBsYXRlICNmaWVsZENvbXBvbmVudD48L25nLXRlbXBsYXRlPlxuICAgIDxkaXYgKm5nSWY9XCJ0by5kZXNjcmlwdGlvblwiPlxuICAgICAgPHNtYWxsIGNsYXNzPVwidGV4dC1tdXRlZFwiPnt7IHRvLmRlc2NyaXB0aW9uIH19PC9zbWFsbD5cbiAgICA8L2Rpdj5cbiAgYCxcbn0pXG5leHBvcnQgY2xhc3MgRm9ybWx5V3JhcHBlckRlc2NyaXB0aW9uIGV4dGVuZHMgRmllbGRXcmFwcGVyIHtcbiAgQFZpZXdDaGlsZCgnZmllbGRDb21wb25lbnQnLCB7cmVhZDogVmlld0NvbnRhaW5lclJlZn0pIGZpZWxkQ29tcG9uZW50OiBWaWV3Q29udGFpbmVyUmVmO1xufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBWaWV3Q2hpbGQsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZpZWxkV3JhcHBlciB9IGZyb20gJ0BuZ3gtZm9ybWx5L2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdmb3JtbHktd3JhcHBlci12YWxpZGF0aW9uLW1lc3NhZ2VzJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctdGVtcGxhdGUgI2ZpZWxkQ29tcG9uZW50PjwvbmctdGVtcGxhdGU+XG4gICAgPGRpdiAqbmdJZj1cInNob3dFcnJvclwiPlxuICAgICAgPHNtYWxsIGNsYXNzPVwidGV4dC1kYW5nZXIgaW52YWxpZC1mZWVkYmFja1wiIFtzdHlsZS5kaXNwbGF5XT1cIidibG9jaydcIiByb2xlPVwiYWxlcnRcIiBbaWRdPVwidmFsaWRhdGlvbklkXCI+XG4gICAgICAgIDxmb3JtbHktdmFsaWRhdGlvbi1tZXNzYWdlIFtmaWVsZF09XCJmaWVsZFwiPjwvZm9ybWx5LXZhbGlkYXRpb24tbWVzc2FnZT5cbiAgICAgIDwvc21hbGw+XG4gICAgPC9kaXY+XG4gIGAsXG59KVxuZXhwb3J0IGNsYXNzIEZvcm1seVdyYXBwZXJWYWxpZGF0aW9uTWVzc2FnZXMgZXh0ZW5kcyBGaWVsZFdyYXBwZXIge1xuICBAVmlld0NoaWxkKCdmaWVsZENvbXBvbmVudCcsIHtyZWFkOiBWaWV3Q29udGFpbmVyUmVmfSkgZmllbGRDb21wb25lbnQ6IFZpZXdDb250YWluZXJSZWY7XG5cbiAgZ2V0IHZhbGlkYXRpb25JZCgpIHtcbiAgICByZXR1cm4gdGhpcy5maWVsZC5pZCArICctbWVzc2FnZSc7XG4gIH1cbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgVmlld0NoaWxkLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGaWVsZFdyYXBwZXIgfSBmcm9tICdAbmd4LWZvcm1seS9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZm9ybWx5LXdyYXBwZXItYWRkb25zJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXBcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvbiBpbnB1dC1ncm91cC1wcmVwZW5kXCJcbiAgICAgICAgKm5nSWY9XCJ0by5hZGRvbkxlZnRcIlxuICAgICAgICBbbmdTdHlsZV09XCJ7Y3Vyc29yOiB0by5hZGRvbkxlZnQub25DbGljayA/ICdwb2ludGVyJyA6ICdpbmhlcml0J31cIlxuICAgICAgICAoY2xpY2spPVwiYWRkb25MZWZ0Q2xpY2soJGV2ZW50KVwiPlxuICAgICAgICA8aSBjbGFzcz1cImlucHV0LWdyb3VwLXRleHRcIiBbbmdDbGFzc109XCJ0by5hZGRvbkxlZnQuY2xhc3NcIiAqbmdJZj1cInRvLmFkZG9uTGVmdC5jbGFzc1wiPjwvaT5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJ0by5hZGRvbkxlZnQudGV4dFwiIGNsYXNzPVwiaW5wdXQtZ3JvdXAtdGV4dFwiPnt7IHRvLmFkZG9uTGVmdC50ZXh0IH19PC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgICA8bmctdGVtcGxhdGUgI2ZpZWxkQ29tcG9uZW50PjwvbmctdGVtcGxhdGU+XG4gICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb24gaW5wdXQtZ3JvdXAtYXBwZW5kXCJcbiAgICAgICAgKm5nSWY9XCJ0by5hZGRvblJpZ2h0XCJcbiAgICAgICAgW25nU3R5bGVdPVwie2N1cnNvcjogdG8uYWRkb25SaWdodC5vbkNsaWNrID8gJ3BvaW50ZXInIDogJ2luaGVyaXQnfVwiXG4gICAgICAgIChjbGljayk9XCJhZGRvblJpZ2h0Q2xpY2soJGV2ZW50KVwiPlxuICAgICAgICA8aSBjbGFzcz1cImlucHV0LWdyb3VwLXRleHRcIiBbbmdDbGFzc109XCJ0by5hZGRvblJpZ2h0LmNsYXNzXCIgKm5nSWY9XCJ0by5hZGRvblJpZ2h0LmNsYXNzXCI+PC9pPlxuICAgICAgICA8c3BhbiAqbmdJZj1cInRvLmFkZG9uUmlnaHQudGV4dFwiIGNsYXNzPVwiaW5wdXQtZ3JvdXAtdGV4dFwiPnt7IHRvLmFkZG9uUmlnaHQudGV4dCB9fTwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICBgLFxuICBzdHlsZXM6IFtgXG4gICAgOmhvc3QgOjpuZy1kZWVwIC5pbnB1dC1ncm91cD46bm90KDpmaXJzdC1jaGlsZCk+IC5mb3JtLWNvbnRyb2wge1xuICAgICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDtcbiAgICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XG4gICAgfVxuICAgIDpob3N0IDo6bmctZGVlcCAuaW5wdXQtZ3JvdXA+Om5vdCg6bGFzdC1jaGlsZCk+IC5mb3JtLWNvbnRyb2wge1xuICAgICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XG4gICAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMDtcbiAgICB9XG4gIGBdLFxufSlcbmV4cG9ydCBjbGFzcyBGb3JtbHlXcmFwcGVyQWRkb25zIGV4dGVuZHMgRmllbGRXcmFwcGVyIHtcbiAgQFZpZXdDaGlsZCgnZmllbGRDb21wb25lbnQnLCB7cmVhZDogVmlld0NvbnRhaW5lclJlZn0pIGZpZWxkQ29tcG9uZW50OiBWaWV3Q29udGFpbmVyUmVmO1xuXG4gIGFkZG9uUmlnaHRDbGljaygkZXZlbnQ6IGFueSkge1xuICAgIGlmICh0aGlzLnRvLmFkZG9uUmlnaHQub25DbGljaykge1xuICAgICAgdGhpcy50by5hZGRvblJpZ2h0Lm9uQ2xpY2sodGhpcy50bywgdGhpcywgJGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBhZGRvbkxlZnRDbGljaygkZXZlbnQ6IGFueSkge1xuICAgIGlmICh0aGlzLnRvLmFkZG9uTGVmdC5vbkNsaWNrKSB7XG4gICAgICB0aGlzLnRvLmFkZG9uTGVmdC5vbkNsaWNrKHRoaXMudG8sIHRoaXMsICRldmVudCk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBGb3JtbHlGaWVsZENvbmZpZywgRm9ybWx5Q29uZmlnIH0gZnJvbSAnQG5neC1mb3JtbHkvY29yZSc7XG5cbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZURlc2NyaXB0aW9uIHtcbiAgcnVuKGZjOiBGb3JtbHlDb25maWcpIHtcbiAgICBmYy50ZW1wbGF0ZU1hbmlwdWxhdG9ycy5wb3N0V3JhcHBlci5wdXNoKChmaWVsZDogRm9ybWx5RmllbGRDb25maWcpID0+IHtcbiAgICAgIGlmICghZmllbGQudGVtcGxhdGVPcHRpb25zIHx8IGZpZWxkLnRlbXBsYXRlT3B0aW9ucy5kZXNjcmlwdGlvbldyYXBwZXIgIT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiAnZGVzY3JpcHRpb24nO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgeyBGb3JtbHlGaWVsZENvbmZpZywgRm9ybWx5Q29uZmlnIH0gZnJvbSAnQG5neC1mb3JtbHkvY29yZSc7XG5cbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZVZhbGlkYXRpb24ge1xuICBydW4oZmM6IEZvcm1seUNvbmZpZykge1xuICAgIGZjLnRlbXBsYXRlTWFuaXB1bGF0b3JzLnBvc3RXcmFwcGVyLnB1c2goKGZpZWxkOiBGb3JtbHlGaWVsZENvbmZpZykgPT4ge1xuICAgICAgaWYgKCFmaWVsZC50ZW1wbGF0ZU9wdGlvbnMgfHwgZmllbGQudGVtcGxhdGVPcHRpb25zLnZhbGlkYXRpb25XcmFwcGVyICE9PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gJ3ZhbGlkYXRpb24tbWVzc2FnZSc7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEZvcm1seUNvbmZpZyB9IGZyb20gJ0BuZ3gtZm9ybWx5L2NvcmUnO1xuXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVBZGRvbnMge1xuICBydW4oZmM6IEZvcm1seUNvbmZpZykge1xuICAgIGZjLnRlbXBsYXRlTWFuaXB1bGF0b3JzLnBvc3RXcmFwcGVyLnB1c2goKGZpZWxkKSA9PiB7XG4gICAgICBpZiAoZmllbGQgJiYgZmllbGQudGVtcGxhdGVPcHRpb25zICYmIChmaWVsZC50ZW1wbGF0ZU9wdGlvbnMuYWRkb25MZWZ0IHx8IGZpZWxkLnRlbXBsYXRlT3B0aW9ucy5hZGRvblJpZ2h0KSkge1xuICAgICAgICByZXR1cm4gJ2FkZG9ucyc7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IENvbmZpZ09wdGlvbiB9IGZyb20gJ0BuZ3gtZm9ybWx5L2NvcmUnO1xuaW1wb3J0IHsgRm9ybWx5V3JhcHBlckFkZG9ucyB9IGZyb20gJy4vd3JhcHBlcnMvYWRkb25zJztcbmltcG9ydCB7IFRlbXBsYXRlRGVzY3JpcHRpb24gfSBmcm9tICcuL3J1bi9kZXNjcmlwdGlvbic7XG5pbXBvcnQgeyBUZW1wbGF0ZVZhbGlkYXRpb24gfSBmcm9tICcuL3J1bi92YWxpZGF0aW9uJztcbmltcG9ydCB7IFRlbXBsYXRlQWRkb25zIH0gZnJvbSAnLi9ydW4vYWRkb24nO1xuaW1wb3J0IHtcbiAgRm9ybWx5RmllbGRJbnB1dCxcbiAgRm9ybWx5RmllbGRDaGVja2JveCxcbiAgRm9ybWx5RmllbGRSYWRpbyxcbiAgRm9ybWx5RmllbGRTZWxlY3QsXG4gIEZvcm1seUZpZWxkVGV4dEFyZWEsXG4gIEZvcm1seUZpZWxkTXVsdGlDaGVja2JveCxcbn0gZnJvbSAnLi90eXBlcy90eXBlcyc7XG5pbXBvcnQge1xuICBGb3JtbHlXcmFwcGVyTGFiZWwsXG4gIEZvcm1seVdyYXBwZXJEZXNjcmlwdGlvbixcbiAgRm9ybWx5V3JhcHBlclZhbGlkYXRpb25NZXNzYWdlcyxcbiAgRm9ybWx5V3JhcHBlckZpZWxkc2V0LFxufSBmcm9tICcuL3dyYXBwZXJzL3dyYXBwZXJzJztcblxuZXhwb3J0IGNvbnN0IEZJRUxEX1RZUEVfQ09NUE9ORU5UUyA9IFtcbiAgLy8gdHlwZXNcbiAgRm9ybWx5RmllbGRJbnB1dCxcbiAgRm9ybWx5RmllbGRDaGVja2JveCxcbiAgRm9ybWx5RmllbGRSYWRpbyxcbiAgRm9ybWx5RmllbGRTZWxlY3QsXG4gIEZvcm1seUZpZWxkVGV4dEFyZWEsXG4gIEZvcm1seUZpZWxkTXVsdGlDaGVja2JveCxcblxuICAvLyB3cmFwcGVyc1xuICBGb3JtbHlXcmFwcGVyTGFiZWwsXG4gIEZvcm1seVdyYXBwZXJEZXNjcmlwdGlvbixcbiAgRm9ybWx5V3JhcHBlclZhbGlkYXRpb25NZXNzYWdlcyxcbiAgRm9ybWx5V3JhcHBlckZpZWxkc2V0LFxuICBGb3JtbHlXcmFwcGVyQWRkb25zLFxuXTtcblxuZXhwb3J0IGNvbnN0IEJPT1RTVFJBUF9GT1JNTFlfQ09ORklHOiBDb25maWdPcHRpb24gPSB7XG4gIHR5cGVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2lucHV0JyxcbiAgICAgIGNvbXBvbmVudDogRm9ybWx5RmllbGRJbnB1dCxcbiAgICAgIHdyYXBwZXJzOiBbJ2ZpZWxkc2V0JywgJ2xhYmVsJ10sXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY2hlY2tib3gnLFxuICAgICAgY29tcG9uZW50OiBGb3JtbHlGaWVsZENoZWNrYm94LFxuICAgICAgd3JhcHBlcnM6IFsnZmllbGRzZXQnXSxcbiAgICAgIGRlZmF1bHRPcHRpb25zOiB7XG4gICAgICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgICAgIGluZGV0ZXJtaW5hdGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3JhZGlvJyxcbiAgICAgIGNvbXBvbmVudDogRm9ybWx5RmllbGRSYWRpbyxcbiAgICAgIHdyYXBwZXJzOiBbJ2ZpZWxkc2V0JywgJ2xhYmVsJ10sXG4gICAgICBkZWZhdWx0T3B0aW9uczoge1xuICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICBvcHRpb25zOiBbXSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc2VsZWN0JyxcbiAgICAgIGNvbXBvbmVudDogRm9ybWx5RmllbGRTZWxlY3QsXG4gICAgICB3cmFwcGVyczogWydmaWVsZHNldCcsICdsYWJlbCddLFxuICAgICAgZGVmYXVsdE9wdGlvbnM6IHtcbiAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgb3B0aW9uczogW10sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3RleHRhcmVhJyxcbiAgICAgIGNvbXBvbmVudDogRm9ybWx5RmllbGRUZXh0QXJlYSxcbiAgICAgIHdyYXBwZXJzOiBbJ2ZpZWxkc2V0JywgJ2xhYmVsJ10sXG4gICAgICBkZWZhdWx0T3B0aW9uczoge1xuICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICBjb2xzOiAxLFxuICAgICAgICAgIHJvd3M6IDEsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ211bHRpY2hlY2tib3gnLFxuICAgICAgY29tcG9uZW50OiBGb3JtbHlGaWVsZE11bHRpQ2hlY2tib3gsXG4gICAgICB3cmFwcGVyczogWydmaWVsZHNldCcsICdsYWJlbCddLFxuICAgICAgZGVmYXVsdE9wdGlvbnM6IHtcbiAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgb3B0aW9uczogW10sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gIF0sXG4gIHdyYXBwZXJzOiBbXG4gICAge25hbWU6ICdsYWJlbCcsIGNvbXBvbmVudDogRm9ybWx5V3JhcHBlckxhYmVsfSxcbiAgICB7bmFtZTogJ2Rlc2NyaXB0aW9uJywgY29tcG9uZW50OiBGb3JtbHlXcmFwcGVyRGVzY3JpcHRpb259LFxuICAgIHtuYW1lOiAndmFsaWRhdGlvbi1tZXNzYWdlJywgY29tcG9uZW50OiBGb3JtbHlXcmFwcGVyVmFsaWRhdGlvbk1lc3NhZ2VzfSxcbiAgICB7bmFtZTogJ2ZpZWxkc2V0JywgY29tcG9uZW50OiBGb3JtbHlXcmFwcGVyRmllbGRzZXR9LFxuICAgIHtuYW1lOiAnYWRkb25zJywgY29tcG9uZW50OiBGb3JtbHlXcmFwcGVyQWRkb25zfSxcbiAgXSxcbiAgbWFuaXB1bGF0b3JzOiBbXG4gICAge2NsYXNzOiBUZW1wbGF0ZURlc2NyaXB0aW9uLCBtZXRob2Q6ICdydW4nfSxcbiAgICB7Y2xhc3M6IFRlbXBsYXRlVmFsaWRhdGlvbiwgbWV0aG9kOiAncnVuJ30sXG4gICAge2NsYXNzOiBUZW1wbGF0ZUFkZG9ucywgbWV0aG9kOiAncnVuJ30sXG4gIF0sXG59O1xuIiwiaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgYXMgb2JzZXJ2YWJsZU9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBGb3JtbHlGaWVsZENvbmZpZyB9IGZyb20gJ0BuZ3gtZm9ybWx5L2NvcmUnO1xuXG5AUGlwZSh7IG5hbWU6ICdmb3JtbHlTZWxlY3RPcHRpb25zJyB9KVxuZXhwb3J0IGNsYXNzIEZvcm1seVNlbGVjdE9wdGlvbnNQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gIHRyYW5zZm9ybShvcHRpb25zLCBmaWVsZD86IEZvcm1seUZpZWxkQ29uZmlnKSB7XG4gICAgaWYgKCEob3B0aW9ucyBpbnN0YW5jZW9mIE9ic2VydmFibGUpKSB7XG4gICAgICBvcHRpb25zID0gb2JzZXJ2YWJsZU9mKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiAob3B0aW9ucyBhcyBPYnNlcnZhYmxlPGFueT4pLnBpcGUoXG4gICAgICBtYXAodmFsdWUgPT4gdGhpcy50b09wdGlvbnModmFsdWUsIGZpZWxkIHx8IHt9KSksXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgdG9PcHRpb25zKG9wdGlvbnMsIGZpZWxkOiBGb3JtbHlGaWVsZENvbmZpZykge1xuICAgIGNvbnN0IGdPcHRpb25zOiBhbnlbXSA9IFtdLFxuICAgICAgZ3JvdXBzOiB7IFtrZXk6IHN0cmluZ106IGFueVtdIH0gPSB7fSxcbiAgICAgIHRvID0gZmllbGQudGVtcGxhdGVPcHRpb25zIHx8IHt9O1xuXG4gICAgb3B0aW9ucy5tYXAoKG9wdGlvbjogYW55KSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZ2V0R3JvdXBQcm9wKG9wdGlvbiwgdG8pKSB7XG4gICAgICAgIGdPcHRpb25zLnB1c2godGhpcy50b09wdGlvbihvcHRpb24sIHRvKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWdyb3Vwc1t0aGlzLmdldEdyb3VwUHJvcChvcHRpb24sIHRvKV0pIHtcbiAgICAgICAgICBncm91cHNbdGhpcy5nZXRHcm91cFByb3Aob3B0aW9uLCB0byldID0gW107XG4gICAgICAgICAgZ09wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBsYWJlbDogdGhpcy5nZXRHcm91cFByb3Aob3B0aW9uLCB0byksXG4gICAgICAgICAgICBncm91cDogZ3JvdXBzW3RoaXMuZ2V0R3JvdXBQcm9wKG9wdGlvbiwgdG8pXSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBncm91cHNbdGhpcy5nZXRHcm91cFByb3Aob3B0aW9uLCB0byldLnB1c2godGhpcy50b09wdGlvbihvcHRpb24sIHRvKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZ09wdGlvbnM7XG4gIH1cblxuICBwcml2YXRlIHRvT3B0aW9uKGl0ZW0sIHRvKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiB0aGlzLmdldExhYmVsUHJvcChpdGVtLCB0byksXG4gICAgICB2YWx1ZTogdGhpcy5nZXRWYWx1ZVByb3AoaXRlbSwgdG8pLFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGdldExhYmVsUHJvcChpdGVtLCB0byk6IHN0cmluZyB7XG4gICAgaWYgKHR5cGVvZiB0by5sYWJlbFByb3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0by5sYWJlbFByb3AoaXRlbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1bdG8ubGFiZWxQcm9wIHx8ICdsYWJlbCddO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRWYWx1ZVByb3AoaXRlbSwgdG8pOiBzdHJpbmcge1xuICAgIGlmICh0eXBlb2YgdG8udmFsdWVQcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdG8udmFsdWVQcm9wKGl0ZW0pO1xuICAgIH1cblxuICAgIHJldHVybiBpdGVtW3RvLnZhbHVlUHJvcCB8fCAndmFsdWUnXTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0R3JvdXBQcm9wKGl0ZW0sIHRvKTogc3RyaW5nIHtcbiAgICBpZiAodHlwZW9mIHRvLmdyb3VwUHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRvLmdyb3VwUHJvcChpdGVtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbVt0by5ncm91cFByb3AgfHwgJ2dyb3VwJ107XG4gIH1cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgUmVhY3RpdmVGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEZvcm1seU1vZHVsZSB9IGZyb20gJ0BuZ3gtZm9ybWx5L2NvcmUnO1xuaW1wb3J0IHsgQk9PVFNUUkFQX0ZPUk1MWV9DT05GSUcsIEZJRUxEX1RZUEVfQ09NUE9ORU5UUyB9IGZyb20gJy4vYm9vdHN0cmFwLmNvbmZpZyc7XG5pbXBvcnQgeyBGb3JtbHlTZWxlY3RPcHRpb25zUGlwZSB9IGZyb20gJy4vc2VsZWN0LW9wdGlvbnMucGlwZSc7XG5cbkBOZ01vZHVsZSh7XG4gIGRlY2xhcmF0aW9uczogW1xuICAgIEZJRUxEX1RZUEVfQ09NUE9ORU5UUyxcbiAgICBGb3JtbHlTZWxlY3RPcHRpb25zUGlwZSxcbiAgXSxcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgIEZvcm1seU1vZHVsZS5mb3JSb290KEJPT1RTVFJBUF9GT1JNTFlfQ09ORklHKSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgRm9ybWx5Qm9vdHN0cmFwTW9kdWxlIHtcbn1cbiJdLCJuYW1lcyI6WyJvYnNlcnZhYmxlT2YiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUEseUJBbUJpQyxTQUFRLFNBQVM7OztZQWhCakQsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSx1QkFBdUI7Z0JBQ2pDLFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7O0dBWVQ7YUFDRjs7Ozs7OztBQ2xCRCw4QkFxQnNDLFNBQVEsU0FBUzs7Ozs7O0lBQ3JELE9BQU8sYUFBYSxDQUFDLEtBQVUsRUFBRSxLQUF3QjtRQUN2RCxJQUFJLEVBQUUsS0FBSyxDQUFDLGVBQWUsQ0FBQyxPQUFPLFlBQVksVUFBVSxDQUFDLEVBQUU7WUFDMUQscUJBQUksa0JBQWtCLEdBQUcsS0FBSyxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxFQUFFLE1BQU07Z0JBQzdFLFFBQVEsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxXQUFXLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUM7Z0JBQzlFLE9BQU8sUUFBUSxDQUFDO2FBQ2pCLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFFUCxPQUFPLElBQUksU0FBUyxDQUNsQixrQkFBa0IsRUFDbEIsS0FBSyxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDLFVBQVUsR0FBRyxTQUFTLEVBQzFELEtBQUssQ0FBQyxlQUFlLEdBQUcsS0FBSyxDQUFDLGVBQWUsQ0FBQyxVQUFVLEdBQUcsU0FBUyxDQUNyRSxDQUFDO1NBQ0g7YUFBTTtZQUNMLE1BQU0sSUFBSSxLQUFLLENBQUMsc0VBQXNFLENBQUMsQ0FBQztTQUN6RjtLQUNGOzs7WUFoQ0YsU0FBUyxTQUFDO2dC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